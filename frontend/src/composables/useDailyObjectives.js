import { ref, computed, watch } from 'vue'
import { useUserStore } from '@/stores/user'
import { updateUserXP } from '@/api/users'

// Ã‰tat partagÃ© (singleton) pour les stats d'objectifs (quiz et exercices)
const sharedUserStats = ref({
  quizEasy: 0,
  quizMedium: 0,
  quizHard: 0,
  quizPerfect: 0,
  quizStreak: 0,
  exercicesCompleted: 0
})

let objectivesInitialized = false

// Composable pour gÃ©rer les objectifs journaliers
export function useDailyObjectives() {
  const userStore = useUserStore()
  
  // Utiliser l'Ã©tat partagÃ© pour que toutes les pages voient la mÃªme progression
  const userStats = sharedUserStats

  // DÃ©finition des objectifs journaliers (quiz et exercices)
  const objectiveTypes = {
    quiz_easy: {
      icon: 'ðŸŸ¢',
      getText: (target) => `RÃ©ussir ${target} quiz simples`,
      xpReward: 3,
      getProgress: () => userStats.value.quizEasy
    },
    quiz_medium: {
      icon: 'ðŸŸ¡',
      getText: (target) => `RÃ©ussir ${target} quiz moyens`,
      xpReward: 5,
      getProgress: () => userStats.value.quizMedium
    },
    quiz_hard: {
      icon: 'ðŸ”´',
      getText: (target) => `RÃ©ussir ${target} quiz difficiles`,
      xpReward: 8,
      getProgress: () => userStats.value.quizHard
    },
    quiz_perfect: {
      icon: 'ðŸŽ¯',
      getText: (target) => `Obtenir 100% sur ${target} quiz`,
      xpReward: 9,
      getProgress: () => userStats.value.quizPerfect
    },
    quiz_streak: {
      icon: 'âš¡',
      getText: (target) => `RÃ©ussir ${target} quiz d'affilÃ©e`,
      xpReward: 9,
      getProgress: () => userStats.value.quizStreak
    },
    exercices_completed: {
      icon: 'ðŸ“š',
      getText: (target) => `RÃ©ussir ${target} exercices`,
      xpReward: 5,
      getProgress: () => userStats.value.exercicesCompleted
    }
  }

  // Mapping fiable entre type d'objectif et clÃ© du state
  const typeToStatKey = (type) => {
    const map = {
      quiz_easy: 'quizEasy',
      quiz_medium: 'quizMedium',
      quiz_hard: 'quizHard',
      quiz_perfect: 'quizPerfect',
      quiz_streak: 'quizStreak',
      exercices_completed: 'exercicesCompleted'
    }
    return map[type] || null
  }

  // Configuration des objectifs journaliers (6 dÃ©fis Ã  dÃ©bloquer alÃ©atoirement - quiz et exercices)
  const dailyObjectivesConfig = [
    { name: 'Quiz simples', type: 'quiz_easy', target: 3 },
    { name: 'Quiz moyens', type: 'quiz_medium', target: 5 },
    { name: 'Quiz difficiles', type: 'quiz_hard', target: 6 },
    { name: 'Quiz parfaits', type: 'quiz_perfect', target: 2 },
    { name: 'SÃ©rie de quiz', type: 'quiz_streak', target: 7 },
    { name: 'Exercices rÃ©ussis', type: 'exercices_completed', target: 2 }
  ]

  // Ã‰tat des objectifs dÃ©bloquÃ©s
  const unlockedObjectives = ref([])

  // Initialiser les objectifs dÃ©bloquÃ©s
  const initializeUnlockedObjectives = () => {
    const today = new Date().toDateString()
    const saved = localStorage.getItem(`unlocked_objectives_${today}`)

    if (saved) {
      let savedObjectives = JSON.parse(saved)
      // Filtrer les index invalides (anciens objectifs supprimÃ©s)
      savedObjectives = savedObjectives.filter(index => 
        index >= 0 && index < dailyObjectivesConfig.length
      )
      
      if (savedObjectives.length > 0) {
        unlockedObjectives.value = savedObjectives
        console.log(`ðŸŽ¯ [DailyObjectives] Objectifs chargÃ©s (nettoyÃ©s):`, unlockedObjectives.value)
      } else {
        // Si tous les objectifs sauvegardÃ©s sont invalides, recommencer
        const randomIndex = Math.floor(Math.random() * dailyObjectivesConfig.length)
        unlockedObjectives.value = [randomIndex]
        console.log(`ðŸŽ¯ [DailyObjectives] Objectifs invalides supprimÃ©s, nouveau dÃ©part:`, randomIndex)
      }
      
      // Sauvegarder les objectifs nettoyÃ©s
      saveUnlockedObjectives()
    } else {
      // Commencer avec un objectif alÃ©atoire
      const randomIndex = Math.floor(Math.random() * dailyObjectivesConfig.length)
      unlockedObjectives.value = [randomIndex]
      saveUnlockedObjectives()
      console.log(`ðŸŽ¯ [DailyObjectives] Premier objectif dÃ©bloquÃ©:`, randomIndex, dailyObjectivesConfig[randomIndex].name)
    }
  }

  // Sauvegarder les objectifs dÃ©bloquÃ©s
  const saveUnlockedObjectives = () => {
    const today = new Date().toDateString()
    localStorage.setItem(`unlocked_objectives_${today}`, JSON.stringify(unlockedObjectives.value))
    console.log(`ðŸŽ¯ [DailyObjectives] Objectifs sauvegardÃ©s:`, unlockedObjectives.value)
  }

  // DÃ©bloquer le prochain objectif dans l'ordre (pas alÃ©atoire)
  const unlockNextObjective = () => {
    const allIndices = Array.from({ length: dailyObjectivesConfig.length }, (_, i) => i)
    const availableIndices = allIndices.filter(i => !unlockedObjectives.value.includes(i))

    if (availableIndices.length > 0) {
      // Prendre le premier objectif disponible (ordre sÃ©quentiel)
      const nextIndex = availableIndices[0]
      unlockedObjectives.value.push(nextIndex)
      saveUnlockedObjectives()
      console.log(`ðŸŽ¯ [DailyObjectives] Nouvel objectif dÃ©bloquÃ© (sÃ©quentiel):`, nextIndex, dailyObjectivesConfig[nextIndex].name)
      
      // Ã‰mettre un Ã©vÃ©nement pour notifier le dÃ©blocage
      window.dispatchEvent(new CustomEvent('objectiveUnlocked', {
        detail: { 
          objective: dailyObjectivesConfig[nextIndex],
          index: nextIndex
        }
      }))
    } else {
      console.log(`ðŸŽ¯ [DailyObjectives] Tous les objectifs sont dÃ©jÃ  dÃ©bloquÃ©s !`)
    }
  }

  // Objectifs dÃ©bloquÃ©s seulement
  const unlockedObjectivesList = computed(() => {
    return unlockedObjectives.value
      .filter(index => index < dailyObjectivesConfig.length) // Filtrer les index invalides
      .map(index => {
        const config = dailyObjectivesConfig[index]
        const type = objectiveTypes[config.type]
        
        // VÃ©rifications de sÃ©curitÃ©
        if (!config || !type) {
          console.warn(`ðŸŽ¯ [DailyObjectives] Configuration invalide pour l'index ${index}`)
          return null
        }
        
        const progress = type.getProgress()

        return {
          index,
          name: config.name,
          type: config.type,
          target: config.target,
          xpReward: type.xpReward,
          icon: type.icon,
          text: type.getText(config.target),
          progress,
          isCompleted: progress >= config.target,
          percentage: Math.min((progress / config.target) * 100, 100)
        }
      })
      .filter(obj => obj !== null) // Supprimer les objets invalides
  })

  // Objectif actuel (le premier non complÃ©tÃ© parmi les dÃ©bloquÃ©s)
  const currentObjective = computed(() => {
    const objectives = unlockedObjectivesList.value
    if (objectives.length === 0) return null

    // Chercher le premier objectif non complÃ©tÃ©
    const incomplete = objectives.find(obj => !obj.isCompleted)
    
    if (incomplete) {
      return incomplete
    }
    
    // Si tous les objectifs dÃ©bloquÃ©s sont complÃ©tÃ©s, dÃ©bloquer automatiquement un nouveau
    const availableIndices = Array.from({ length: dailyObjectivesConfig.length }, (_, i) => i)
      .filter(i => !unlockedObjectives.value.includes(i))
    
    if (availableIndices.length > 0) {
      // DÃ©bloquer le prochain objectif disponible (pas alÃ©atoire)
      const nextIndex = availableIndices[0]
      console.log(`ðŸŽ¯ [DailyObjectives] Auto-dÃ©blocage objectif ${nextIndex}`)
      unlockedObjectives.value.push(nextIndex)
      saveUnlockedObjectives()
      
      // Retourner le nouvel objectif dÃ©bloquÃ©
      const config = dailyObjectivesConfig[nextIndex]
      const type = objectiveTypes[config.type]
      const statKey = typeToStatKey(config.type)
      const progress = statKey ? userStats.value[statKey] : 0
      
      return {
        ...config,
        ...type,
        progress,
        isCompleted: progress >= config.target,
        isUnlocked: true
      }
    }
    
    // Si tous les objectifs sont dÃ©bloquÃ©s et complÃ©tÃ©s
    return null
  })

  // Tous les objectifs avec leur statut (pour le modal)
  const allObjectives = computed(() => {
    return dailyObjectivesConfig.map((config, index) => {
      const isUnlocked = unlockedObjectives.value.includes(index)
      const type = objectiveTypes[config.type]
      
      // VÃ©rifications de sÃ©curitÃ©
      if (!config || !type) {
        console.warn(`ðŸŽ¯ [DailyObjectives] Configuration invalide pour l'index ${index}`)
        return null
      }
      
      const progress = isUnlocked ? type.getProgress() : 0

      return {
        index,
        name: config.name,
        type: config.type,
        target: config.target,
        xpReward: type.xpReward,
        icon: type.icon,
        text: type.getText(config.target),
        progress,
        isCompleted: isUnlocked && progress >= config.target,
        isUnlocked,
        percentage: isUnlocked ? Math.min((progress / config.target) * 100, 100) : 0
      }
    }).filter(obj => obj !== null) // Supprimer les objets invalides
  })

  // ClÃ© pour localStorage basÃ©e sur la date
  const getStorageKey = (type) => {
    const today = new Date().toDateString()
    return `daily_objective_${type}_${today}`
  }

  // Charger les statistiques depuis localStorage
  const loadTodayStats = () => {
    Object.keys(objectiveTypes).forEach(type => {
      const key = getStorageKey(type)
      const saved = localStorage.getItem(key)
      const statKey = typeToStatKey(type)
      if (saved && statKey && Object.prototype.hasOwnProperty.call(userStats.value, statKey)) {
        userStats.value[statKey] = parseInt(saved, 10) || 0
      }
    })
  }

  // Sauvegarder les statistiques
  const saveStats = () => {
    Object.keys(objectiveTypes).forEach(type => {
      const key = getStorageKey(type)
      const statKey = typeToStatKey(type)
      const value = statKey ? userStats.value[statKey] : 0
      localStorage.setItem(key, String(value ?? 0))
    })
  }

  // IncrÃ©menter une statistique
  const incrementStat = (statType, amount = 1) => {
    const statKey = typeToStatKey(statType)
    console.log(`ðŸŽ¯ [DailyObjectives] incrementStat appelÃ©: ${statType} â†’ ${statKey}`)
    
    if (statKey && Object.prototype.hasOwnProperty.call(userStats.value, statKey)) {
      const oldValue = userStats.value[statKey]
      userStats.value[statKey] += amount
      const newValue = userStats.value[statKey]
      
      console.log(`ðŸŽ¯ [DailyObjectives] ${statKey} mis Ã  jour: ${oldValue} â†’ ${newValue}`)
      
      saveStats()
      
      // Notifier le dashboard pour une mise Ã  jour instantanÃ©e
      try {
        window.dispatchEvent(new CustomEvent('dailyObjectiveProgress', {
          detail: { type: statType, value: newValue }
        }))
        console.log(`ðŸŽ¯ [DailyObjectives] Ã‰vÃ©nement Ã©mis pour ${statType}`)
      } catch (error) {
        console.error(`ðŸŽ¯ [DailyObjectives] Erreur Ã©vÃ©nement:`, error)
      }
      
      // VÃ©rifier et attribuer les rÃ©compenses aprÃ¨s chaque mise Ã  jour
      setTimeout(() => {
        checkAndAwardObjectives()
      }, 100)
    } else {
      console.error(`ðŸŽ¯ [DailyObjectives] Stat invalide: ${statType} â†’ ${statKey}`)
      console.error(`ðŸŽ¯ [DailyObjectives] userStats disponibles:`, Object.keys(userStats.value))
    }
  }

  // RÃ©initialiser les stats du jour (si nÃ©cessaire)
  const resetDailyStats = () => {
    Object.keys(userStats.value).forEach(key => {
      userStats.value[key] = 0
    })
    saveStats()
  }

  // VÃ©rifier si l'objectif du jour est complÃ©tÃ©
  const isDailyObjectiveCompleted = computed(() => {
    return currentObjective.value.progress >= currentObjective.value.target
  })

  // VÃ©rifier si un objectif a dÃ©jÃ  Ã©tÃ© rÃ©compensÃ© aujourd'hui
  const getObjectiveRewardKey = (objectiveType) => {
    const today = new Date().toDateString()
    return `daily_objective_reward_${objectiveType}_${today}`
  }

  const hasObjectiveBeenRewarded = (objectiveType) => {
    const key = getObjectiveRewardKey(objectiveType)
    return localStorage.getItem(key) === 'true'
  }

  const markObjectiveAsRewarded = (objectiveType) => {
    const key = getObjectiveRewardKey(objectiveType)
    localStorage.setItem(key, 'true')
  }

  // Attribuer les XP pour un objectif complÃ©tÃ©
  const awardObjectiveXP = async (objectiveType, xpAmount) => {
    if (hasObjectiveBeenRewarded(objectiveType)) {
      return false // DÃ©jÃ  rÃ©compensÃ© aujourd'hui
    }

    console.log(`ðŸŽ¯ [DailyObjectives] Attribution XP: ${xpAmount} pour ${objectiveType}`)
    
    try {
      // Sauvegarder les XP dans le backend
      await updateUserXP({
        xp_delta: xpAmount,
        reason: `daily_objective:${objectiveType}`
      })
      
      // Mettre Ã  jour le userStore local
      const oldXP = userStore.xp || 0
      userStore.xp = oldXP + xpAmount
      
      console.log(`ðŸŽ¯ [DailyObjectives] XP sauvegardÃ©s backend et store: ${oldXP} â†’ ${userStore.xp}`)
      
      // Marquer comme rÃ©compensÃ©
      markObjectiveAsRewarded(objectiveType)
      
      // Ã‰mettre un Ã©vÃ©nement pour notification
      setTimeout(() => {
        console.log(`ðŸŽ¯ [DailyObjectives] Ã‰mission notification pour ${objectiveType}`)
        window.dispatchEvent(new CustomEvent('dailyObjectiveCompleted', {
          detail: { objectiveType, xpAmount }
        }))
      }, 500)
      
    } catch (error) {
      console.error(`ðŸŽ¯ [DailyObjectives] Erreur sauvegarde XP:`, error)
      
      // En cas d'erreur, mettre Ã  jour quand mÃªme le store local
      const oldXP = userStore.xp || 0
      userStore.xp = oldXP + xpAmount
      
      // Ã‰mettre quand mÃªme la notification
      window.dispatchEvent(new CustomEvent('dailyObjectiveCompleted', {
        detail: { objectiveType, xpAmount }
      }))
    }
    
    return true // XP attribuÃ©s avec succÃ¨s
  }

  // VÃ©rifier et attribuer les rÃ©compenses automatiquement
  const checkAndAwardObjectives = () => {
    let hasNewCompletion = false
    
    unlockedObjectivesList.value.forEach(objective => {
      if (objective.isCompleted && !hasObjectiveBeenRewarded(objective.type)) {
        console.log(`ðŸŽ¯ [DailyObjectives] Objectif complÃ©tÃ©: ${objective.name}`)
        hasNewCompletion = true
        
        // Attribuer les XP
        awardObjectiveXP(objective.type, objective.xpReward)
      }
    })
    
    // Si un objectif vient d'Ãªtre complÃ©tÃ©, dÃ©bloquer un nouveau aprÃ¨s un dÃ©lai
    if (hasNewCompletion) {
      setTimeout(() => {
        // VÃ©rifier s'il reste des objectifs Ã  dÃ©bloquer
        const availableIndices = Array.from({ length: dailyObjectivesConfig.length }, (_, i) => i)
          .filter(i => !unlockedObjectives.value.includes(i))
        
        if (availableIndices.length > 0) {
          console.log(`ðŸŽ¯ [DailyObjectives] DÃ©blocage d'un nouvel objectif...`)
          unlockNextObjective()
        } else {
          console.log(`ðŸŽ¯ [DailyObjectives] Tous les objectifs sont dÃ©jÃ  dÃ©bloquÃ©s !`)
        }
      }, 1500) // DÃ©lai pour laisser le temps Ã  la notification de s'afficher
    }
  }

  // Obtenir la progression en pourcentage
  const getProgressPercentage = (objective) => {
    return Math.min(100, (objective.progress / objective.target) * 100)
  }

  // Simuler des Ã©vÃ©nements pour tester (Ã  supprimer en production)
  const simulateQuizEasy = () => incrementStat('quiz_easy')
  const simulateQuizMedium = () => incrementStat('quiz_medium')
  const simulateQuizHard = () => incrementStat('quiz_hard')
  const simulateQuizPerfect = () => incrementStat('quiz_perfect')
  const simulateExerciseCompleted = () => incrementStat('exercices_completed')
  const simulateQuizStreak = (count) => {
    userStats.value.quizStreak = Math.max(userStats.value.quizStreak, count)
    saveStats()
    // Notifier le dashboard et tenter d'attribuer les rÃ©compenses
    try {
      window.dispatchEvent(new CustomEvent('dailyObjectiveProgress', {
        detail: { type: 'quiz_streak', value: userStats.value.quizStreak }
      }))
    } catch {}
    setTimeout(() => {
      checkAndAwardObjectives()
    }, 100)
  }

  // Watcher pour sauvegarder automatiquement (une fois)
  if (!objectivesInitialized) {
    loadTodayStats()
    initializeUnlockedObjectives()
    watch(userStats, saveStats, { deep: true })
    objectivesInitialized = true
  }

  return {
    userStats,
    currentObjective,
    unlockedObjectives,
    unlockedObjectivesList,
    allObjectives,
    isDailyObjectiveCompleted,
    getProgressPercentage,
    incrementStat,
    resetDailyStats,
    loadTodayStats,
    checkAndAwardObjectives,
    awardObjectiveXP,
    hasObjectiveBeenRewarded,
    
    // Fonctions de simulation pour tests
    simulateQuizEasy,
    simulateQuizMedium,
    simulateQuizHard,
    simulateQuizPerfect,
    simulateExerciseCompleted,
    simulateQuizStreak
  }
}

// IntÃ©gration avec les vraies actions utilisateur
export function useDailyObjectivesIntegration() {
  const { incrementStat, simulateQuizStreak } = useDailyObjectives()
  
  // Gestion du streak quotidien (succÃ¨s consÃ©cutifs)
  const getTodayKey = (suffix) => `${suffix}_${new Date().toDateString()}`
  const loadCurrentSuccessStreak = () => {
    const raw = localStorage.getItem(getTodayKey('daily_quiz_success_streak'))
    return raw ? parseInt(raw, 10) || 0 : 0
  }
  const saveCurrentSuccessStreak = (value) => {
    localStorage.setItem(getTodayKey('daily_quiz_success_streak'), String(value))
  }

  // Fonctions Ã  appeler lors des vraies actions utilisateur
  const onQuizCompleted = (quizResult) => {
    console.log('[DailyObjectives] Quiz completed:', quizResult)
    console.log('[DailyObjectives] Quiz difficulty:', quizResult.difficulty)
    console.log('[DailyObjectives] Quiz success:', quizResult.isSuccess)
    
    if (quizResult.isSuccess) {
      // TOUJOURS incrÃ©menter les quiz par difficultÃ© quand rÃ©ussis
      const difficulty = quizResult.difficulty?.toLowerCase?.() || 'easy'
      console.log('[DailyObjectives] DifficultÃ© dÃ©tectÃ©e:', difficulty)
      
      if (difficulty === 'facile' || difficulty === 'easy') {
        console.log('[DailyObjectives] Quiz facile rÃ©ussi - IncrÃ©mentation quiz_easy')
        incrementStat('quiz_easy')
      } else if (difficulty === 'moyen' || difficulty === 'moyenne' || difficulty === 'medium') {
        console.log('[DailyObjectives] Quiz moyen rÃ©ussi - IncrÃ©mentation quiz_medium')
        incrementStat('quiz_medium')
      } else if (difficulty === 'difficile' || difficulty === 'hard') {
        console.log('[DailyObjectives] Quiz difficile rÃ©ussi - IncrÃ©mentation quiz_hard')
        incrementStat('quiz_hard')
      }

      // Mettre Ã  jour le streak de succÃ¨s consÃ©cutifs
      let streak = loadCurrentSuccessStreak()
      streak = streak + 1
      saveCurrentSuccessStreak(streak)
      console.log('[DailyObjectives] Streak success mis Ã  jour:', streak)
      simulateQuizStreak(streak)
    } else {
      console.log('[DailyObjectives] Quiz Ã©chouÃ© - Pas d\'incrÃ©mentation')
      // Ã‰chec: rÃ©initialiser le streak
      saveCurrentSuccessStreak(0)
      simulateQuizStreak(0)
    }
    
    // GÃ©rer les quiz parfaits (100% de bonnes rÃ©ponses)
    if (quizResult.percentage === 100) {
      console.log('[DailyObjectives] Quiz parfait dÃ©tectÃ© (100%)')
      incrementStat('quiz_perfect')
    }
  }

  // GÃ©rer les sÃ©ries de quiz rÃ©ussis
  const onQuizStreak = (streakCount) => {
    console.log('[DailyObjectives] Quiz streak:', streakCount)
    simulateQuizStreak(streakCount)
  }

  // GÃ©rer la complÃ©tion d'exercices
  const onExerciseCompleted = (exerciseResult) => {
    console.log('[DailyObjectives] Exercise completed:', exerciseResult)
    
    if (exerciseResult.isSuccess) {
      console.log('[DailyObjectives] Exercise rÃ©ussi - IncrÃ©mentation exercices_completed')
      incrementStat('exercices_completed')
    } else {
      console.log('[DailyObjectives] Exercise Ã©chouÃ© - Pas d\'incrÃ©mentation')
    }
  }

  return {
    onQuizCompleted,
    onQuizStreak,
    onExerciseCompleted
  }
}
